var U = Object.defineProperty;
var D = Object.getOwnPropertySymbols;
var B = Object.prototype.hasOwnProperty, K = Object.prototype.propertyIsEnumerable;
var b = (e, r, n) => r in e ? U(e, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[r] = n, y = (e, r) => {
  for (var n in r || (r = {}))
    B.call(r, n) && b(e, n, r[n]);
  if (D)
    for (var n of D(r))
      K.call(r, n) && b(e, n, r[n]);
  return e;
};
var x = (e, r) => {
  var n = {};
  for (var s in e)
    B.call(e, s) && r.indexOf(s) < 0 && (n[s] = e[s]);
  if (e != null && D)
    for (var s of D(e))
      r.indexOf(s) < 0 && K.call(e, s) && (n[s] = e[s]);
  return n;
};
import i, { useRef as O, useEffect as k, useState as A, Children as G, cloneElement as H } from "react";
import o from "prop-types";
import C from "styled-components";
import J from "@strapi/icons/CarretDown";
import { NavLink as Q } from "react-router-dom";
import { Typography as N } from "../Typography/Typography.js";
import { Box as v } from "../Box/Box.js";
import { Flex as X } from "../Flex/Flex.js";
import { Button as $ } from "../Button/Button.js";
import { POPOVER_PLACEMENTS as Y, Popover as Z } from "../Popover/Popover.js";
import { getOptionStyle as F } from "./utils.js";
import { useId as ee } from "../helpers/useId.js";
import { KeyboardKeys as c } from "../helpers/keyboardKeys.js";
const ne = C.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${F}
`, te = C(Q)`
  text-decoration: none;
  ${F}
`, oe = C.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, re = C($)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, V = (T) => {
  var g = T, { children: e, onClick: r, to: n, isFocused: s } = g, E = x(g, ["children", "onClick", "to", "isFocused"]);
  const p = O();
  k(() => {
    s && p.current && p.current.focus();
  }, [s]);
  const h = y({
    tabIndex: s ? 0 : -1,
    ref: p,
    role: "menuitem"
  }, E), R = (l) => {
    (l.key === c.SPACE || l.key === c.ENTER) && r();
  };
  return n ? /* @__PURE__ */ i.createElement(te, y({
    to: n
  }, h), /* @__PURE__ */ i.createElement(v, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(N, null, e))) : /* @__PURE__ */ i.createElement(ne, y({
    onKeyDown: R,
    onMouseDown: r,
    type: "button"
  }, h), /* @__PURE__ */ i.createElement(v, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(N, null, e)));
};
V.defaultProps = {
  onClick: () => {
  },
  isFocused: !1,
  to: void 0
};
V.propTypes = {
  as: o.elementType,
  children: o.node.isRequired,
  isFocused: o.bool,
  onClick: o.func,
  to: o.string
};
const I = (R) => {
  var l = R, {
    label: e,
    children: r,
    id: n,
    as: s,
    onOpen: E = () => {
    },
    onClose: T = () => {
    },
    size: g,
    popoverPlacement: p
  } = l, h = x(l, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement"
  ]);
  const u = O(), M = ee("simplemenu", n), m = O(!1), [f, d] = A(!1), [S, w] = A(0), P = G.toArray(r), q = s || (g === "S" ? re : $);
  k(() => {
    if (["string", "number"].includes(typeof e)) {
      const t = P.findIndex((a) => a.props.children === e);
      t !== -1 && w(t);
    }
  }, [e]), k(() => {
    m != null && m.current ? f && typeof E == "function" ? E() : typeof T == "function" && T() : m.current = !0;
  }, [m, f]), k(() => {
    i.isValidElement(e) && S == -1 && u.current.focus();
  }, [e, S]);
  const L = (t) => {
    f && (t.key === c.ESCAPE && (t.stopPropagation(), d(!1), u.current.focus()), t.key === c.DOWN && w((a) => a === P.length - 1 ? 0 : a + 1), t.key === c.UP && w((a) => a === 0 ? P.length - 1 : a - 1));
  }, W = (t) => {
    (t.key === c.ENTER || t.key === c.SPACE) && d((a) => !a);
  }, _ = (t) => {
    t.preventDefault(), t.currentTarget.contains(t.relatedTarget) || d(!1);
  }, z = (t) => {
    t.preventDefault(), d((a) => !a);
  }, j = P.map((t, a) => /* @__PURE__ */ i.createElement(X, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, H(t, {
    onClick: () => {
      t.props.onClick(), d(!1), u.current.focus();
    },
    isFocused: S === a
  })));
  return /* @__PURE__ */ i.createElement("div", {
    onKeyDown: L
  }, /* @__PURE__ */ i.createElement(q, y({
    label: i.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": f,
    "aria-controls": M,
    onKeyDown: W,
    onMouseDown: z,
    ref: u,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ i.createElement(oe, null, /* @__PURE__ */ i.createElement(J, {
      "aria-hidden": !0
    }))
  }, h), e), f && /* @__PURE__ */ i.createElement(Z, {
    onBlur: _,
    placement: p,
    source: u,
    spacing: 4
  }, /* @__PURE__ */ i.createElement(v, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: M
  }, j)));
};
I.defaultProps = {
  as: void 0
};
I.displayName = "SimpleMenu";
I.defaultProps = {
  popoverPlacement: "bottom-start",
  size: "M"
};
I.propTypes = {
  as: o.any,
  children: o.oneOfType([o.arrayOf(o.node), o.node]).isRequired,
  id: o.string,
  label: o.oneOfType([o.string, o.number, o.element]).isRequired,
  onClose: o.func,
  onOpen: o.func,
  popoverPlacement: o.oneOf(Y),
  size: o.oneOf(["S", "M"])
};
export {
  V as MenuItem,
  I as SimpleMenu
};
