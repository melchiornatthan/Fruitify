var U = Object.defineProperty;
var P = Object.getOwnPropertySymbols;
var v = Object.prototype.hasOwnProperty, K = Object.prototype.propertyIsEnumerable;
var M = (e, r, n) => r in e ? U(e, r, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[r] = n, d = (e, r) => {
  for (var n in r || (r = {}))
    v.call(r, n) && M(e, n, r[n]);
  if (P)
    for (var n of P(r))
      K.call(r, n) && M(e, n, r[n]);
  return e;
};
var x = (e, r) => {
  var n = {};
  for (var s in e)
    v.call(e, s) && r.indexOf(s) < 0 && (n[s] = e[s]);
  if (e != null && P)
    for (var s of P(e))
      r.indexOf(s) < 0 && K.call(e, s) && (n[s] = e[s]);
  return n;
};
import i, { useRef as O, useEffect as D, useState as A, Children as G, cloneElement as H } from "react";
import o from "prop-types";
import C from "styled-components";
import J from "@strapi/icons/CarretDown";
import { Typography as L } from "../../Typography/Typography.js";
import { Box as R } from "../../Box/Box.js";
import { Flex as Q } from "../../Flex/Flex.js";
import { Button as N } from "../../Button/Button.js";
import { BaseLink as X } from "../../BaseLink/BaseLink.js";
import { POPOVER_PLACEMENTS as Y, Popover as Z } from "../../Popover/Popover.js";
import { getOptionStyle as $ } from "./utils.js";
import { useId as ee } from "../../helpers/useId.js";
import { KeyboardKeys as l } from "../../helpers/keyboardKeys.js";
const ne = C.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${$}
`, te = C(X)`
  text-decoration: none;
  ${$}
`, oe = C.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, re = C(N)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, F = (b) => {
  var g = b, { as: e, children: r, onClick: n, isFocused: s, isLink: y } = g, E = x(g, ["as", "children", "onClick", "isFocused", "isLink"]);
  const p = O();
  D(() => {
    s && p.current && p.current.focus();
  }, [s]);
  const T = d({
    tabIndex: s ? 0 : -1,
    ref: p,
    role: "menuitem"
  }, E), h = (c) => {
    (c.key === l.SPACE || c.key === l.ENTER) && n();
  };
  return y ? /* @__PURE__ */ i.createElement(te, d({
    as: e
  }, T), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(L, null, r))) : /* @__PURE__ */ i.createElement(ne, d({
    onKeyDown: h,
    onMouseDown: n,
    type: "button"
  }, T), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(L, null, r)));
};
F.defaultProps = {
  onClick: () => {
  },
  isFocused: !1,
  isLink: !1
};
F.propTypes = {
  as: o.elementType,
  children: o.node.isRequired,
  isFocused: o.bool,
  isLink: o.bool,
  onClick: o.func
};
const I = (T) => {
  var h = T, {
    label: e,
    children: r,
    id: n,
    as: s,
    onOpen: y = () => {
    },
    onClose: E = () => {
    },
    size: b,
    popoverPlacement: g
  } = h, p = x(h, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement"
  ]);
  const c = O(), B = ee("simplemenu", n), u = O(!1), [m, f] = A(!1), [S, w] = A(0), k = G.toArray(r), V = s || (b === "S" ? re : N);
  D(() => {
    if (["string", "number"].includes(typeof e)) {
      const t = k.findIndex((a) => a.props.children === e);
      t !== -1 && w(t);
    }
  }, [e]), D(() => {
    u != null && u.current ? m && typeof y == "function" ? y() : typeof E == "function" && E() : u.current = !0;
  }, [u, m]), D(() => {
    i.isValidElement(e) && S == -1 && c.current.focus();
  }, [e, S]);
  const q = (t) => {
    m && (t.key === l.ESCAPE && (t.stopPropagation(), f(!1), c.current.focus()), t.key === l.DOWN && w((a) => a === k.length - 1 ? 0 : a + 1), t.key === l.UP && w((a) => a === 0 ? k.length - 1 : a - 1));
  }, W = (t) => {
    (t.key === l.ENTER || t.key === l.SPACE) && f((a) => !a);
  }, _ = (t) => {
    t.preventDefault(), t.currentTarget.contains(t.relatedTarget) || f(!1);
  }, z = (t) => {
    t.preventDefault(), f((a) => !a);
  }, j = k.map((t, a) => /* @__PURE__ */ i.createElement(Q, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, H(t, {
    onClick: () => {
      t.props.onClick(), f(!1), c.current.focus();
    },
    isFocused: S === a
  })));
  return /* @__PURE__ */ i.createElement("div", {
    onKeyDown: q
  }, /* @__PURE__ */ i.createElement(V, d({
    label: i.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": m,
    "aria-controls": B,
    onKeyDown: W,
    onMouseDown: z,
    ref: c,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ i.createElement(oe, null, /* @__PURE__ */ i.createElement(J, {
      "aria-hidden": !0
    }))
  }, p), e), m && /* @__PURE__ */ i.createElement(Z, {
    onBlur: _,
    placement: g,
    source: c,
    spacing: 4
  }, /* @__PURE__ */ i.createElement(R, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: B
  }, j)));
};
I.defaultProps = {
  as: void 0
};
I.displayName = "SimpleMenu";
I.defaultProps = {
  popoverPlacement: "bottom-start",
  size: "M"
};
I.propTypes = {
  as: o.any,
  children: o.oneOfType([o.arrayOf(o.node), o.node]).isRequired,
  id: o.string,
  label: o.oneOfType([o.string, o.number, o.element]).isRequired,
  onClose: o.func,
  onOpen: o.func,
  popoverPlacement: o.oneOf(Y),
  size: o.oneOf(["S", "M"])
};
export {
  F as MenuItem,
  I as SimpleMenu
};
