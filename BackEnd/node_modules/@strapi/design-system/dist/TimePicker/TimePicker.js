var _ = Object.defineProperty;
var m = Object.getOwnPropertySymbols;
var g = Object.prototype.hasOwnProperty, y = Object.prototype.propertyIsEnumerable;
var b = (t, o, r) => o in t ? _(t, o, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[o] = r, v = (t, o) => {
  for (var r in o || (o = {}))
    g.call(o, r) && b(t, r, o[r]);
  if (m)
    for (var r of m(o))
      y.call(o, r) && b(t, r, o[r]);
  return t;
};
var O = (t, o) => {
  var r = {};
  for (var s in t)
    g.call(t, s) && o.indexOf(s) < 0 && (r[s] = t[s]);
  if (t != null && m)
    for (var s of m(t))
      o.indexOf(s) < 0 && y.call(t, s) && (r[s] = t[s]);
  return r;
};
import u from "react";
import e from "prop-types";
import j from "@strapi/icons/Clock";
import H from "styled-components";
import { sizes as L } from "../themes/sizes.js";
import { Select as S } from "../Select/Select.js";
import { Option as V } from "../Select/Option.js";
import "../Select/OptGroup.js";
import "../Select/MultiSelectNested.js";
import "../Select/SelectList.js";
import { useId as W } from "../helpers/useId.js";
const A = H.div`
  display: flex;
  align-items: center;
  svg {
    height: 1rem;
    width: 1rem;
  }

  svg path {
    fill: ${({ theme: t }) => t.colors.neutral500};
  }
`, T = (B) => {
  var f = B, {
    disabled: t,
    error: o,
    hint: r,
    id: s,
    onClear: C,
    onChange: M,
    value: c,
    clearLabel: k,
    label: $,
    step: E,
    size: I
  } = f, z = O(f, [
    "disabled",
    "error",
    "hint",
    "id",
    "onClear",
    "onChange",
    "value",
    "clearLabel",
    "label",
    "step",
    "size"
  ]);
  const P = W("timepicker", s), R = 24, n = [];
  let l = 0;
  for (let i = 0; i < R; i++)
    for (l = 0; l < 60; )
      n.push(`${i < 10 ? "0" + i : i}:${l < 10 ? "0" + l : l}`), l += E;
  const q = () => {
    const i = c.split(":")[0], h = c.split(":")[1], w = n.reduce((a, d) => {
      const p = d.split(":")[0];
      return Math.abs(p - i) < Math.abs(a - i) ? p : a;
    }, n[0].split(":")[0]), x = n.reduce((a, d) => {
      const p = d.split(":")[1];
      return Math.abs(p - h) < Math.abs(a - h) ? p : a;
    }, n[0].split(":")[1]);
    return `${w}:${x}`;
  };
  return /* @__PURE__ */ u.createElement(S, v({
    id: P,
    label: $,
    placeholder: "--:--",
    hint: r,
    onClear: C,
    clearLabel: k,
    error: o,
    value: c ? q() : null,
    size: I,
    onChange: M,
    disabled: t,
    startIcon: /* @__PURE__ */ u.createElement(A, null, /* @__PURE__ */ u.createElement(j, null))
  }, z), n.map((i) => /* @__PURE__ */ u.createElement(V, {
    value: i,
    key: i
  }, i)));
};
T.defaultProps = {
  disabled: !1,
  error: void 0,
  hint: void 0,
  id: void 0,
  label: void 0,
  onClear: void 0,
  size: "M",
  step: 15,
  value: void 0
};
T.propTypes = {
  clearLabel: e.string.isRequired,
  disabled: e.bool,
  error: e.string,
  hint: e.oneOfType([e.string, e.node, e.arrayOf(e.node)]),
  id: e.oneOfType([e.string, e.number]),
  label: e.string,
  onChange: e.func.isRequired,
  onClear: e.func,
  size: e.oneOf(Object.keys(L.input)),
  step: e.number,
  value: e.oneOfType([
    e.arrayOf(e.oneOfType([e.string, e.number])),
    e.string,
    e.number
  ])
};
export {
  T as TimePicker
};
