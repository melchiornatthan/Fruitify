"use strict";var T=Object.defineProperty;var u=Object.getOwnPropertySymbols;var y=Object.prototype.hasOwnProperty,b=Object.prototype.propertyIsEnumerable;var p=(e,t,s)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,m=(e,t)=>{for(var s in t||(t={}))y.call(t,s)&&p(e,s,t[s]);if(u)for(var s of u(t))b.call(t,s)&&p(e,s,t[s]);return e};var h=(e,t)=>{var s={};for(var o in e)y.call(e,o)&&t.indexOf(o)<0&&(s[o]=e[o]);if(e!=null&&u)for(var o of u(e))t.indexOf(o)<0&&b.call(e,o)&&(s[o]=e[o]);return s};Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const l=require("react"),_=require("prop-types"),E=require("../helpers/getFocusableNodes.cjs"),g=require("../helpers/keyboardKeys.cjs"),K=e=>e&&typeof e=="object"&&"default"in e?e:{default:e},k=K(l),F=K(_),a=o=>{var f=o,{onEscape:e,restoreFocus:t}=f,s=h(f,["onEscape","restoreFocus"]);const c=l.useRef(null);l.useEffect(()=>{if(t){const r=document.activeElement;return()=>{r.focus()}}},[t]),l.useEffect(()=>{if(!c.current)return;const r=E.getFocusableNodes(c.current);r.length>0?r[0].focus():console.warn("[FocusTrap]: it seems there are no focusable elements in the focus trap tree. Make sure there s at least one.")},[]);const v=r=>{if(r.key===g.KeyboardKeys.ESCAPE&&e)return e();if(r.key!==g.KeyboardKeys.TAB)return;const n=E.getFocusableNodes(c.current);if(n.length>0){const i=n[0],d=n[n.length-1];r.shiftKey?i===document.activeElement&&(r.preventDefault(),d.focus()):d===document.activeElement&&(r.preventDefault(),i.focus())}};return k.default.createElement("div",m({ref:c,onKeyDown:v},s))};a.defaultProps={restoreFocus:!0};a.propTypes={onEscape:F.default.func,restoreFocus:F.default.bool};exports.FocusTrap=a;
