var T = Object.defineProperty;
var f = Object.getOwnPropertySymbols;
var m = Object.prototype.hasOwnProperty, p = Object.prototype.propertyIsEnumerable;
var i = (e, t, r) => t in e ? T(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, d = (e, t) => {
  for (var r in t || (t = {}))
    m.call(t, r) && i(e, r, t[r]);
  if (f)
    for (var r of f(t))
      p.call(t, r) && i(e, r, t[r]);
  return e;
};
var E = (e, t) => {
  var r = {};
  for (var o in e)
    m.call(e, o) && t.indexOf(o) < 0 && (r[o] = e[o]);
  if (e != null && f)
    for (var o of f(e))
      t.indexOf(o) < 0 && p.call(e, o) && (r[o] = e[o]);
  return r;
};
import g, { useRef as D, useEffect as h } from "react";
import y from "prop-types";
import { getFocusableNodes as b } from "../helpers/getFocusableNodes.js";
import { KeyboardKeys as v } from "../helpers/keyboardKeys.js";
const F = (o) => {
  var u = o, { onEscape: e, restoreFocus: t } = u, r = E(u, ["onEscape", "restoreFocus"]);
  const c = D(null);
  h(() => {
    if (t) {
      const n = document.activeElement;
      return () => {
        n.focus();
      };
    }
  }, [t]), h(() => {
    if (!c.current)
      return;
    const n = b(c.current);
    n.length > 0 ? n[0].focus() : console.warn(
      "[FocusTrap]: it seems there are no focusable elements in the focus trap tree. Make sure there s at least one."
    );
  }, []);
  const K = (n) => {
    if (n.key === v.ESCAPE && e)
      return e();
    if (n.key !== v.TAB)
      return;
    const s = b(c.current);
    if (s.length > 0) {
      const l = s[0], a = s[s.length - 1];
      n.shiftKey ? l === document.activeElement && (n.preventDefault(), a.focus()) : a === document.activeElement && (n.preventDefault(), l.focus());
    }
  };
  return /* @__PURE__ */ g.createElement("div", d({
    ref: c,
    onKeyDown: K
  }, r));
};
F.defaultProps = {
  restoreFocus: !0
};
F.propTypes = {
  onEscape: y.func,
  restoreFocus: y.bool
};
export {
  F as FocusTrap
};
